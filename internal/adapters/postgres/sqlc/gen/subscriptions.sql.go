// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subscriptions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getSubscriptionByUserID = `-- name: GetSubscriptionByUserID :one
SELECT
  id, user_id, status, last_pay_date, created_at, payments_count, access_until,
  rebill_id, pm_active, card_brand, last4
FROM subscriptions
WHERE user_id = $1
`

func (q *Queries) GetSubscriptionByUserID(ctx context.Context, userID string) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByUserID, userID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.LastPayDate,
		&i.CreatedAt,
		&i.PaymentsCount,
		&i.AccessUntil,
		&i.RebillID,
		&i.PmActive,
		&i.CardBrand,
		&i.Last4,
	)
	return i, err
}

const setRebillID = `-- name: SetRebillID :exec
UPDATE subscriptions
SET rebill_id = $1,
    pm_active = true,
    card_brand = $2,
    last4 = $3
WHERE user_id = $4
`

type SetRebillIDParams struct {
	RebillID  *string `db:"rebill_id" json:"rebill_id"`
	CardBrand *string `db:"card_brand" json:"card_brand"`
	Last4     *string `db:"last4" json:"last4"`
	UserID    string  `db:"user_id" json:"user_id"`
}

func (q *Queries) SetRebillID(ctx context.Context, arg SetRebillIDParams) error {
	_, err := q.db.Exec(ctx, setRebillID,
		arg.RebillID,
		arg.CardBrand,
		arg.Last4,
		arg.UserID,
	)
	return err
}

const upsertSubscription = `-- name: UpsertSubscription :exec
INSERT INTO subscriptions (
  id, user_id, status, last_pay_date, created_at, payments_count, access_until,
  rebill_id, pm_active, card_brand, last4
) VALUES (
  $1,
  $2,
  $3::subscription_status,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11
)
ON CONFLICT (user_id) DO UPDATE SET
  id=EXCLUDED.id,
  status=EXCLUDED.status,
  last_pay_date=EXCLUDED.last_pay_date,
  payments_count=EXCLUDED.payments_count,
  access_until=EXCLUDED.access_until,
  rebill_id=EXCLUDED.rebill_id,
  pm_active=EXCLUDED.pm_active,
  card_brand=EXCLUDED.card_brand,
  last4=EXCLUDED.last4
`

type UpsertSubscriptionParams struct {
	ID            string             `db:"id" json:"id"`
	UserID        string             `db:"user_id" json:"user_id"`
	Status        SubscriptionStatus `db:"status" json:"status"`
	LastPayDate   pgtype.Timestamptz `db:"last_pay_date" json:"last_pay_date"`
	CreatedAt     pgtype.Timestamptz `db:"created_at" json:"created_at"`
	PaymentsCount int32              `db:"payments_count" json:"payments_count"`
	AccessUntil   pgtype.Timestamptz `db:"access_until" json:"access_until"`
	RebillID      *string            `db:"rebill_id" json:"rebill_id"`
	PmActive      bool               `db:"pm_active" json:"pm_active"`
	CardBrand     *string            `db:"card_brand" json:"card_brand"`
	Last4         *string            `db:"last4" json:"last4"`
}

func (q *Queries) UpsertSubscription(ctx context.Context, arg UpsertSubscriptionParams) error {
	_, err := q.db.Exec(ctx, upsertSubscription,
		arg.ID,
		arg.UserID,
		arg.Status,
		arg.LastPayDate,
		arg.CreatedAt,
		arg.PaymentsCount,
		arg.AccessUntil,
		arg.RebillID,
		arg.PmActive,
		arg.CardBrand,
		arg.Last4,
	)
	return err
}
